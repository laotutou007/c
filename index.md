# C语言

> **C 语言可以写出性能非常强、完全发挥硬件潜力的程序，而且 C 语言的编译器实现难度相对较低。但是另一方面，C 语言代码容易出错，一般程序员不容易写好**
> 

# 标识符

1. 一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）
2. 不能有标点字符，比如@,$,%,区分大小写，manpower 和 Manpower是两个不同的标识符
3. 字符常量只能使用单引号（’  ’）
4. c没有其他高级语言一样灵活，必须按照死公式
5. 标识符多数用于变量声明，

# 基本类型

1. 不同的变量类型存储的空间大小不同
2. 大体类型：
    - 基本类型：
        - 整数类型
        - 浮点类型
    - 枚举类型
        - 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。
    - void类型
        - 表明没有可用的值
    - 派生类型
        - 指针类型、数组类型、结构类型、共用体类型和函数类型
3. 基本数据类型占用空间
    - char ： 1个字节
    - int ：4个字节
    - float：4个字节
    - double：8个字节

     整数

- a，默认为10进制 ，10 ，20。
- b，以0开头为8进制，045，021。
- c.，以0b开头为2进制，0b11101101。
- d，以0x开头为16进制，0x21458adf。

     **小数**

        单精度常量：2.3f 。

        双精度常量：2.3，默认为双精度。

**字符型常量**

        用英文单引号括起来，只保存一个字符'a'、'b' 、'*' ，还有转义字符 '\n' 、'\t'。

**字符串常量**

用英文的双引号引起来 可以保存多个字符："abc"。

1. c本身是一种编译性的语言，源码都是文本文件，本身无法执行，必须通过编译器，生成二进制可执行文件

# 代码规范

```c
#include<stido.h>
int main(){
	//执行代码内容
	return 0;
}
```

规定符

- **%d** 十进制有符号整数
- **%u** 十进制无符号整数
- **%f** 浮点数
- **%s** 字符串
- **%c** 单个字符
- **%p** 指针的值
- **%e** 指数形式的浮点数
- **%x, %X** 无符号以十六进制表示的整数
- **%o** 无符号以八进制表示的整数
- **%g** 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出
- **%p** 输出地址符
- **%lu** 32位无符号整数
- **%llu** 64位无符号整数

> c语言有多个类型个关键字，关键字决定不同的意义，有定义变量值是多少的（常量，类型），还有是代码结构的使用
> 

所谓“占位符”，就是这个位置可以用其他值代入。

```c
/*----------------占位符的特殊使用----------------*/
printf("value of c is %d\n",c);
    printf("Ben says %s is %i\n","it",88);
    printf("%5d\n",34);//从右往左走，多出来的位置按空格算
		printf("%-5d\n",32);//从左往右，空格在数的后面
    printf("%3f\n",12.1);//没有规定的小数，小数点后输出默认是6位
		printf("%.3f\n",11.9);//规定浮点数后面的小数点宽度
		printf("%+d\n",341);//输出正 +341
		pirntf("%-d\n",-241);//输出负，前提是（值是负的）才能输出带“-”的符号
```

# 变量值

在声明一个变量后，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。

# scope（作用域）

file scope  

从源码顶层去赋值，从文件开始到结束都有效

block scope

在{ }内赋值有一个单独的作用域，只在当前代码块里面有效

> 代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。规则：内从代码块可以调用外层，但是外层代码块，不能调用内层。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量
> 

# 运算符

运算符`/`用来完成除法。注意，两个整数相除，得到还是一个整数。

c语言里面，整数除法是整除，只会返回整数部分，丢弃小数部分

```c
float x = 6 / 4;
printf("%f\n", x); // 输出 1.000000
```

除非相除的两个数中至少有一个是包含小数点的

```c
float x = 6.0 / 4; // 或者写成 6 / 4.0
printf("%f\n", x); // 输出 1.500000
```

！ 非运算符

&& 与运算符 

| |  或运算符

# 位运算

C 语言提供一些位运算符，用来操作二进制位（bit）。

（1）取反运算符`～`

取反运算符`～`是一个一元运算符，用来将每一个二进制位变成相反值，即`0`变成`1`，`1`变成`0`。

```
// 返回 01101100
~ 10010011

```

上面示例中，`~`对每个二进制位取反，就得到了一个新的值。

注意，`~`运算符不会改变变量的值，只是返回一个新的值。

（2）与运算符`&`

与运算符`&`将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为`1`，就返回`1`，否则返回`0`。

```
// 返回 00010001
10010011 & 00111101

```

上面示例中，两个八位二进制数进行逐位比较，返回一个新的值。

与运算符`&`可以与赋值运算符`=`结合，简写成`&=`。

```
int val = 3;
val = val & 0377;

// 简写成
val &= 0377;

```

（3）或运算符`|`

或运算符`|`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为`1`（包含两个都为`1`的情况），就返回`1`，否则返回`0`。

```
// 返回 10111111
10010011 | 00111101

```

或运算符`|`可以与赋值运算符`=`结合，简写成`|=`。

```
int val = 3;
val = val | 0377;

// 简写为
val |= 0377;

```

（4）异或运算符`^`

异或运算符`^`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为`1`，就返回`1`，否则返回`0`。

```
// 返回 10101110
10010011 ^ 00111101

```

异或运算符`^`可以与赋值运算符`=`结合，简写成`^=`。

```c
int val = 3;
val = val ^ 0377;

// 简写为
val ^= 0377;

```

（5）左移运算符`<<`

左移运算符`<<`将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用`0`填充。

```c
// 1000101000
10001010 << 2

```

上面示例中，`10001010`的每一个二进制位，都向左侧移动了两位。

左移运算符相当于将运算数乘以2的指定次方，比如左移2位相当于乘以4（2的2次方）。

左移运算符`<<`可以与赋值运算符`=`结合，简写成`<<=`。

```c
int val = 1;
val = val << 2;

// 简写为
val <<= 2;

```

（6）右移运算符`>>`

右移运算符`>>`将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用`0`填充。

```c
// 返回 00100010
10001010 >> 2

```

上面示例中，`10001010`的每一个二进制位，都向右移动两位。最低的两位`10`被丢弃，头部多出来的两位补`0`，所以最后得到`00100010`。

注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。

右移运算符相当于将运算数除以2的指定次方，比如右移2位就相当于除以4（2的2次方）。

右移运算符`>>`可以与赋值运算符`=`结合，简写成`>>=`。

```c
int val = 1;
val = val >> 2;

// 简写为
val >>= 2;
```

# 指针

声明指针后和变量一样都是随机的(全局变量会初始化)，不过不是值是地址

变量前+&访问的是地址值

声明指针，指针存储地址值，每个变量都会在生成的时候存在一个地址值，在使用函数的时候，行参变量值只是拷贝的值，不会去修改本身的值，如果
